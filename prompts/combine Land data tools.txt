I have a tool and scritp ready for its file name is : pipeline/6_phone_number_vacant_lot.py
which contain script i will prodive
next  i have file name main02.py which contain that tool UI
----
Now I want to replicate this tool but it should be properly replicates it
means that it has separate workings:
So for that purpose I have create a file for new tool based on old tool 
new file name is:
pipeline/resident_data.py
So make change in main02.py which add tool, new tool name is "Resident Data"
make main02.py file and resident_data.py
Script of Old Tool is: 6_phone_number_vacant_lot.py


import pandas as pd
import os
import re

# -------------------------------
# Helpers
# -------------------------------
def to_pascal_case(text):
    if pd.isna(text):
        return text
    return ' '.join(word.capitalize() for word in str(text).split())

def normalize_address(addr):
    if pd.isna(addr): return ""
    addr = str(addr).strip().lower()
    addr = re.sub(r"\s+", " ", addr)
    return addr

def ensure_folder(folder):
    if not os.path.exists(folder):
        os.makedirs(folder, exist_ok=True)

def step_01_prepare_emails(df):
    if 'Email' in df.columns:
        # make lowercase + strip spaces
        df['Email'] = df['Email'].astype(str).str.strip().str.lower()
    else:
        # if no email column, create an empty one
        df['Email'] = ""
    return df


# -------------------------------
# STEP 03.5: Remove Type columns from CC Ready files
# -------------------------------
def remove_type_columns_from_cc_ready(file_path, has_type3_max=False):
    """
    Remove Type1‚ÄìType6 columns from CC Ready files but KEEP Email
    Preserve temporary Type4-6 columns if they were created for Type3 max input
    """
    try:
        df = pd.read_excel(file_path)

        # Remove Type columns, but preserve temporary ones if created for Type3 max
        columns_to_remove = ['Type1', 'Type2', 'Type3']
        if not has_type3_max:
            columns_to_remove.extend(['Type4', 'Type5', 'Type6'])
        
        df = df.drop(columns=[col for col in columns_to_remove if col in df.columns], errors='ignore')

        # Save back
        writer = pd.ExcelWriter(file_path, engine='xlsxwriter')
        df.to_excel(writer, sheet_name='Sheet1', index=False)

        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        no_border_format = workbook.add_format({'border': 0})

        for col_num, value in enumerate(df.columns.values):
            worksheet.write(0, col_num, value, no_border_format)

        writer.close()
        print(f"‚úÖ Removed Type columns from: {file_path}")
        return df

    except Exception as e:
        print(f"‚ùå Error processing CC Ready file: {str(e)}")
        return None

# -------------------------------
# STEP 01
# -------------------------------
def step_01_clean_and_standardize(df, list_name):
    # Check if input has max Type3 (no Type4/Phone4)
    has_type3_max = ('Type4' not in df.columns and 'Phone4' not in df.columns and 
                     'Type3' in df.columns)
    
    # Create temporary columns if needed
    if has_type3_max:
        print(f"‚ö†Ô∏è  Input has max Type3. Creating temporary Phone4-6, Type4-6 columns.")
        for i in range(4, 7):
            phone_col = f'phone_{i}'
            type_col = f'phone_{i}_type'
            if phone_col not in df.columns:
                df[phone_col] = None
            if type_col not in df.columns:
                df[type_col] = None
    

    df['Email'] = df['Email'].astype(str).str.strip().str.lower()

    

    cleaned = df.rename(columns={
        'first_name': 'First Name',
        'last_name': 'Last Name',
        'associated_property_address_line_1': 'Property Address',
        'associated_property_address_city': 'Property City',
        'associated_property_address_state': 'Property State',
        'associated_property_address_zipcode': 'Property Zip',
        'primary_mailing_address': 'Mailing Address',
        'primary_mailing_city': 'Mailing City',
        'primary_mailing_state': 'Mailing State',
        'primary_mailing_zip': 'Mailing Zip',
        'phone_1': 'Phone1',
        'phone_2': 'Phone2',
        'phone_3': 'Phone3',
        'phone_4': 'Phone4',
        'phone_5': 'Phone5',
        'phone_6': 'Phone6',
        'phone_1_type': 'Type1',
        'phone_2_type': 'Type2',
        'phone_3_type': 'Type3',
        'phone_4_type': 'Type4',
        'phone_5_type': 'Type5',
        'phone_6_type': 'Type6',
        'email': 'Email'
    })

    if 'Mailing Address' in cleaned.columns:
        cleaned['Mailing Address'] = cleaned['Mailing Address'].apply(to_pascal_case)
    if 'Mailing City' in cleaned.columns:
        cleaned['Mailing City'] = cleaned['Mailing City'].apply(to_pascal_case)



    if 'Email' in df.columns:
     df['Email'] = df['Email'].astype(str).str.strip().str.lower()
    else:
     df['Email'] = ""  # create empty if not found

    
    df['Email'] = df['Email'].astype(str).str.strip().str.lower()

    

    # Define base columns to keep (excluding Parcel Id for now)
    base_columns_to_keep = [
        'First Name', 'Last Name',
        'Property Address', 'Property City', 'Property State', 'Property Zip',
        'Mailing Address', 'Mailing City', 'Mailing State', 'Mailing Zip',
        'Phone1', 'Type1', 'Phone2', 'Type2', 'Phone3', 'Type3',
        'Phone4', 'Type4', 'Phone5', 'Type5', 'Phone6', 'Type6',
        'Email',
    ]

    # Only include Parcel Id if it exists in the original dataframe
    if 'Parcel Id' in cleaned.columns:
        base_columns_to_keep.insert(10, 'Parcel Id')  # Insert at position 10 (after Mailing Zip)

    cleaned = cleaned[[col for col in base_columns_to_keep if col in cleaned.columns]]
    cleaned['List'] = list_name
    
    return cleaned, has_type3_max

# -------------------------------
# STEP 02
# -------------------------------
def step_02_remove_phones(df):
    # Define base columns to remove (excluding Parcel Id for now)
    columns_to_remove = [
        'Phone1','Type1','Phone2','Type2','Phone3','Type3',
        'Phone4','Type4','Phone5','Type5','Phone6','Type6','Email'
    ]
    
    # Only remove Parcel Id if it exists in the dataframe
    # if 'Parcel Id' in df.columns:
    #     columns_to_remove.append('Parcel Id')
    
    return df.drop(columns=[col for col in columns_to_remove if col in df.columns], errors='ignore')

# -------------------------------
# STEP 03
# -------------------------------
def step_03_dedupe_and_cleanup(df, list_name, output_folder=None):
    # df = df.drop_duplicates()
    # if 'Property Address' in df.columns:
    #     df['normalized_address'] = df['Property Address'].apply(normalize_address)
    #     df = df.drop_duplicates(subset=['normalized_address'])
    #     df = df.drop(columns=['normalized_address'], errors='ignore')




    phone_cols = [f'Phone{i}' for i in range(1,7) if f'Phone{i}' in df.columns]
    if phone_cols:
        mask_no_phones = df[phone_cols].isna().all(axis=1)
    else:
        mask_no_phones = pd.Series([True]*len(df), index=df.index)

    df_no_hit = df[mask_no_phones].copy()

    if not df_no_hit.empty and output_folder:
        no_hit_folder = os.path.join(output_folder, "No Hit")
        ensure_folder(no_hit_folder)
        no_hit_path = os.path.join(no_hit_folder, f"{list_name}.xlsx")

        writer = pd.ExcelWriter(no_hit_path, engine='xlsxwriter')
        df_no_hit.to_excel(writer, sheet_name='Sheet1', index=False)

        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        no_border_format = workbook.add_format({'border': 0})

        for col_num, value in enumerate(df_no_hit.columns.values):
            worksheet.write(0, col_num, value, no_border_format)

        writer.close()
        print(f"üìÇ No Hit file created at: {no_hit_path}")

    df = df[~mask_no_phones]
    df = df.drop_duplicates()

    if 'Parcel Id' in df.columns:
    # Remove blanks in Parcel Id
     df = df[df['Parcel Id'].notna() & (df['Parcel Id'].astype(str).str.strip() != "")]
    # Remove duplicates based on Parcel Id
    df = df.drop_duplicates(subset=['Parcel Id'])
    df['List'] = list_name
    return df

# -------------------------------
# STEP 04
# -------------------------------
def step_04_process_phones(df):
    phone_cols = [f'Phone{i}' for i in range(1,7) if f'Phone{i}' in df.columns]
    if phone_cols:
        df = df[df[phone_cols].notna().any(axis=1)].copy()

    # Remove landlines
    for i in range(1, 7):
        phone_col = f'Phone{i}'
        type_col = f'Type{i}'
        if type_col in df.columns:
            df.loc[df[type_col].astype(str).str.lower() == 'landline', phone_col] = None

    # Core address columns (without Email) - conditionally include Parcel Id
    address_columns = [
        'First Name', 'Last Name',
        'Property Address', 'Property City', 'Property State', 'Property Zip',
        'Mailing Address', 'Mailing City', 'Mailing State', 'Mailing Zip'
    ]
    
    # Only include Parcel Id if it exists
    if 'Parcel Id' in df.columns:
        address_columns.append('Parcel Id')

    # Clean property zip
    if 'Property Zip' in df.columns:
        df['Property Zip'] = df['Property Zip'].astype(str).str.split('-').str[0]
        df['Property Zip'] = pd.to_numeric(df['Property Zip'], errors='coerce').fillna(0).astype(int)

    # Separate rows where first 3 phones are blank ‚Üí shift 4‚Äì6
    mask_blank_first3 = True
    phone1_present = 'Phone1' in df.columns
    phone2_present = 'Phone2' in df.columns
    phone3_present = 'Phone3' in df.columns
    cols_first3 = [c for c in ['Phone1','Phone2','Phone3'] if c in df.columns]
    if cols_first3:
        mask_blank_first3 = df[cols_first3].isna().all(axis=1)
    else:
        mask_blank_first3 = pd.Series([False]*len(df), index=df.index)

    df_4_2 = df[mask_blank_first3].copy()

    if not df_4_2.empty:
        df_4_2_processed = df_4_2[address_columns + ['Email', 'Phone4', 'Phone5', 'Phone6', 'List']].copy()
        df_4_2_processed.rename(columns={'Phone4': 'Phone1', 'Phone5': 'Phone2', 'Phone6': 'Phone3'}, inplace=True)
        df_4_2 = df_4_2_processed[address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List']]
    else:
        df_4_2 = pd.DataFrame(columns=address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List'])

    # Keep rows with first 3 phones
    # ensure Phone4-6 present as None
    for col in ['Phone4','Phone5','Phone6']:
        if col not in df.columns:
            df[col] = None

    df_4_1 = df[~mask_blank_first3].copy()
    df_4_1 = df_4_1[address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List']].copy()

    # Combine and drop empties
    df_combined = pd.concat([df_4_1, df_4_2], ignore_index=True)
    phone_cols_first3 = [c for c in ['Phone1','Phone2','Phone3'] if c in df_combined.columns]
    if phone_cols_first3:
        df_combined = df_combined[df_combined[phone_cols_first3].notna().any(axis=1)]

    return df_combined

# -------------------------------
# STEP 05
# -------------------------------
def step_05_reshape(df):
    def extract_numeric_phone(phone):
        return phone  # keep as-is

    phone_cols = [col for col in df.columns if col.lower().startswith("phone")]

    output_rows = []
    for _, row in df.iterrows():
        record = {
            "First Name": row.get("First Name", ""),
            "Last Name": row.get("Last Name", ""),
            "Property Address": row.get("Property Address", ""),
            "Property City": row.get("Property City", ""),
            "Property State": row.get("Property State", ""),
            "Property Zip": row.get("Property Zip", ""),
            "Mailing Address": row.get("Mailing Address", ""),
            "Mailing City": row.get("Mailing City", ""),
            "Mailing State": row.get("Mailing State", ""),
            "Mailing Zip": row.get("Mailing Zip", ""),
            "Email": row.get("Email", ""),
            "List": row.get("List", "")
        }
        
        # Only include Parcel Id if it exists
        if 'Parcel Id' in df.columns:
            record["Parcel Id"] = row.get("Parcel Id", "")

        # collect valid phones
        phone_numbers = []
        for phone_col in phone_cols:
            val = row.get(phone_col, None)
            if pd.notna(val) and str(val).strip() not in ["", "nan", "none", "null", "0"]:
                phone_numbers.append(extract_numeric_phone(val))

        if not phone_numbers:
            continue

        for phone in phone_numbers:
            rec_copy = record.copy()
            # Force final order: Phone ‚Üí Email ‚Üí List
            rec_copy = {
                **{k: rec_copy[k] for k in rec_copy if k not in ["Email", "List"]},
                "Phone": phone,
                "Email": rec_copy["Email"],
                "List": rec_copy["List"]
            }
            output_rows.append(rec_copy)

    return pd.DataFrame(output_rows)

# -------------------------------
# Save helper
# -------------------------------
def save_to_folder(df, folder, list_name, suffix=""):
    ensure_folder(folder)
    filepath = os.path.join(folder, f"{list_name}{suffix}.xlsx")
    df = df.fillna('')

    writer = pd.ExcelWriter(filepath, engine='xlsxwriter')
    df.to_excel(writer, sheet_name='Sheet1', index=False)

    workbook = writer.book
    worksheet = writer.sheets['Sheet1']
    no_border_format = workbook.add_format({'border': 0})

    for col_num, value in enumerate(df.columns.values):
        worksheet.write(0, col_num, value, no_border_format)

    writer.close()
    print(f"‚úÖ Saved: {filepath}")
    return filepath

# -------------------------------
# Clean up temporary columns ONLY from Step01 file
# -------------------------------
def cleanup_step01_temporary_columns(file_path):
    """
    Remove temporary Phone4-6 and Type4-6 columns from Step01 file only
    """
    try:
        df = pd.read_excel(file_path)
        
        # Remove temporary columns
        temp_cols_to_remove = []
        for i in range(4, 7):
            temp_cols_to_remove.extend([f'Phone{i}', f'Type{i}'])
        
        # Only remove columns that exist and are empty (temporary ones)
        cols_to_remove = []
        for col in temp_cols_to_remove:
            if col in df.columns and df[col].isna().all():
                cols_to_remove.append(col)
        
        if cols_to_remove:
            df = df.drop(columns=cols_to_remove, errors='ignore')
            
            # Save back
            writer = pd.ExcelWriter(file_path, engine='xlsxwriter')
            df.to_excel(writer, sheet_name='Sheet1', index=False)

            workbook = writer.book
            worksheet = writer.sheets['Sheet1']
            no_border_format = workbook.add_format({'border': 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()
            print(f"‚úÖ Cleaned up temporary columns from Step01 file: {file_path}")
        else:
            print(f"‚ÑπÔ∏è No temporary columns found in Step01 file: {file_path}")
        
    except Exception as e:
        print(f"‚ùå Error cleaning up temporary columns from Step01 file: {str(e)}")

# -------------------------------
# Clean up temporary columns from No Hit file
# -------------------------------
def cleanup_nohit_temporary_columns(file_path):
    """
    Remove temporary Phone4-6 and Type4-6 columns from No Hit file
    """
    if not os.path.exists(file_path):
        return None
        
    try:
        df = pd.read_excel(file_path)
        
        # Remove temporary columns
        temp_cols_to_remove = []
        for i in range(4, 7):
            temp_cols_to_remove.extend([f'Phone{i}', f'Type{i}'])
        
        # Only remove columns that exist
        cols_to_remove = [col for col in temp_cols_to_remove if col in df.columns]
        
        if cols_to_remove:
            df = df.drop(columns=cols_to_remove, errors='ignore')
            
            # Save back
            writer = pd.ExcelWriter(file_path, engine='xlsxwriter')
            df.to_excel(writer, sheet_name='Sheet1', index=False)

            workbook = writer.book
            worksheet = writer.sheets['Sheet1']
            no_border_format = workbook.add_format({'border': 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()
            print(f"‚úÖ Cleaned up temporary columns from No Hit file: {file_path}")
        
    except Exception as e:
        print(f"‚ùå Error cleaning up temporary columns from No Hit file: {str(e)}")
        return None

# -------------------------------
# Remove Phone6 from CC Ready
# -------------------------------

def remove_phone6_and_type_columns_from_cc_ready(file_path):
    try:
        df = pd.read_excel(file_path)
        
        # Remove Phone6 if it exists
        columns_removed = []
        if "Phone6" in df.columns:
            df = df.drop(columns=["Phone6"], errors="ignore")
            columns_removed.append("Phone6")
        
        # Remove ALL Type columns if they exist
        type_columns = ['Type1', 'Type2', 'Type3', 'Type4', 'Type5', 'Type6']
        type_cols_to_remove = [col for col in type_columns if col in df.columns]
        
        if type_cols_to_remove:
            df = df.drop(columns=type_cols_to_remove, errors="ignore")
            columns_removed.extend(type_cols_to_remove)
        
        if columns_removed:
            # Save back
            writer = pd.ExcelWriter(file_path, engine="xlsxwriter")
            df.to_excel(writer, sheet_name="Sheet1", index=False)

            workbook = writer.book
            worksheet = writer.sheets["Sheet1"]
            no_border_format = workbook.add_format({"border": 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()
            print(f"‚úÖ Removed columns from CC Ready file: {', '.join(columns_removed)}")
        else:
            print(f"‚ÑπÔ∏è No columns to remove from CC Ready file: {file_path}")
            
        return df
        
    except Exception as e:
        print(f"‚ùå Error removing columns from CC Ready file: {str(e)}")
        return None

# def remove_phone6_from_cc_ready(file_path):
#     try:
#         df = pd.read_excel(file_path)
#         if "Phone6" in df.columns:
#             df = df.drop(columns=["Phone6"], errors="ignore")

#             writer = pd.ExcelWriter(file_path, engine="xlsxwriter")
#             df.to_excel(writer, sheet_name="Sheet1", index=False)

#             workbook = writer.book
#             worksheet = writer.sheets["Sheet1"]
#             no_border_format = workbook.add_format({"border": 0})

#             for col_num, value in enumerate(df.columns.values):
#                 worksheet.write(0, col_num, value, no_border_format)

#             writer.close()
#             print(f"‚úÖ Removed Phone6 column from: {file_path}")
#         return df
#     except Exception as e:
#         print(f"‚ùå Error removing Phone6 from CC Ready file: {str(e)}")
#         return None

def reorder_nohit_file(no_hit_path):
    """
    If No Hit file exists, reorder its columns so that:
    Phone1, Type1, ..., Phone6, Type6, Email, List
    """
    if os.path.exists(no_hit_path):
        try:
            df = pd.read_excel(no_hit_path)

            # Define the desired column order
            phone_type_cols = []
            for i in range(1, 7):
                phone_type_cols.append(f"Phone{i}")
                phone_type_cols.append(f"Type{i}")

            final_order = phone_type_cols + ["Email", "List"]

            # Keep only columns that exist in df
            ordered_cols = [col for col in final_order if col in df.columns]
            remaining_cols = [col for col in df.columns if col not in ordered_cols]

            df = df[ remaining_cols + ordered_cols]

            # Overwrite the file with reordered columns
            writer = pd.ExcelWriter(no_hit_path, engine="xlsxwriter")
            df.to_excel(writer, sheet_name="Sheet1", index=False)

            workbook = writer.book
            worksheet = writer.sheets["Sheet1"]
            no_border_format = workbook.add_format({"border": 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()

            print(f"‚úÖ Reordered columns in No Hit file: {no_hit_path}")
            return df

        except Exception as e:
            print(f"‚ùå Error reordering No Hit file: {e}")
            return None
    else:
        print(f"‚ÑπÔ∏è No Hit file not found at {no_hit_path}")
        return None

# -------------------------------
# RUN PIPELINE
# -------------------------------
def run_pipeline(input_path, list_name, output_folder, keep_outputs=None):
    """
    Runs the full vacant-lot 6-phone pipeline for a single input file.
    keep_outputs: list of labels to keep. If None => keep everything.
    Labels: "SkipTraced", "2BSkip", "CC Ready", "SC Ready", "GHL Ready", "No Hit File"
    """
    # Create Processed folder
    processed_folder = os.path.join(output_folder, "Processed")
    ensure_folder(processed_folder)
    
    # Create individual output folder inside Processed
    individual_output_folder = os.path.join(processed_folder, list_name)
    ensure_folder(individual_output_folder)

    # Subfolders
    subfolders = ["SkipTraced", "2BSkip", "CC Ready", "SC Ready", "GHL Ready", "No Hit"]
    for folder in subfolders:
        ensure_folder(os.path.join(individual_output_folder, folder))

    step01_folder = os.path.join(individual_output_folder, "SkipTraced")
    filepath_01 = os.path.join(step01_folder, f"{list_name}.xlsx")

    has_type3_max = False
    
    if os.path.exists(filepath_01):
        print(f"Found existing step01 file: {filepath_01}. Loading it instead of reprocessing.")
        df_01 = pd.read_excel(filepath_01)
        # Check if this file has temporary columns by checking if Phone4 exists but is all empty
        if 'Phone4' in df_01.columns and df_01['Phone4'].isna().all():
            has_type3_max = True
    else:
        if input_path.endswith('.csv'):
            df_raw = pd.read_csv(input_path)
        elif input_path.endswith('.xlsx'):
            df_raw = pd.read_excel(input_path)
        else:
            raise ValueError("Unsupported input file type.")
        
        # Check if input has max Type3 (no Type4/Phone4)
        has_type3_max = ('Type4' not in df_raw.columns and 'Phone4' not in df_raw.columns and 
                        'Type3' in df_raw.columns)
        
        df_01, _ = step_01_clean_and_standardize(df_raw, list_name)
        save_to_folder(df_01, step01_folder, list_name)

    df_02 = step_02_remove_phones(df_01)
    filepath_02 = save_to_folder(df_02, os.path.join(individual_output_folder, "2BSkip"), list_name)

    df_03 = step_03_dedupe_and_cleanup(df_01, list_name, individual_output_folder)
    filepath_03 = save_to_folder(df_03, os.path.join(individual_output_folder, "CC Ready"), list_name)

    df_04 = step_04_process_phones(pd.read_excel(filepath_03))
    filepath_04 = save_to_folder(df_04, os.path.join(individual_output_folder, "SC Ready"), list_name)

    df_05 = step_05_reshape(pd.read_excel(filepath_04))
    filepath_05 = save_to_folder(df_05, os.path.join(individual_output_folder, "GHL Ready"), list_name)

    # Post-processing tweaks - pass has_type3_max to preserve temporary Type columns
    # remove_phone6_from_cc_ready(filepath_03)
    # remove_type_columns_from_cc_ready(filepath_03, has_type3_max)
    remove_phone6_and_type_columns_from_cc_ready(filepath_03)

    # Reorder No Hit file if it exists
    reorder_nohit_file(os.path.join(individual_output_folder, "No Hit", f"{list_name}.xlsx"))

    # Clean up temporary columns from Step01 and No Hit files if needed
    if has_type3_max:
        cleanup_step01_temporary_columns(filepath_01)
        no_hit_path = os.path.join(individual_output_folder, "No Hit", f"{list_name}.xlsx")
        cleanup_nohit_temporary_columns(no_hit_path)

    # Tracker
    no_hit_path = os.path.join(individual_output_folder, "No Hit", f"{list_name}.xlsx")

    tracker_data = {
        "SkipTraced": filepath_01,
        "2BSkip": filepath_02,
        "CC Ready": filepath_03,
        "SC Ready": filepath_04,
        "GHL Ready": filepath_05,
        "No Hit File": no_hit_path
    }

    tracker_lines = []
    for label, path in tracker_data.items():
        try:
            if os.path.exists(path):
                df_tmp = pd.read_excel(path)
                count = df_tmp["List"].notna().sum() if "List" in df_tmp.columns else len(df_tmp)
            else:
                count = 0  # If file missing ‚Üí 0
            tracker_lines.append(f"{label}: {count}")
        except Exception as e:
            tracker_lines.append(f"{label}: Error reading file - {str(e)}")

    tracker_path = os.path.join(individual_output_folder, "List Building Records.txt")
    with open(tracker_path, "w") as f:
        f.write("\n".join(tracker_lines))


    print("üìã Tracker saved at:", tracker_path)





    # If keep_outputs specified, remove any outputs NOT listed
    if keep_outputs is not None:
        # map "No Hit File" label to how user likely sees "No Hit" checkbox
        allowed_labels = set(keep_outputs)
        # Accept both "No Hit" and "No Hit File" synonyms
        if "No Hit" in allowed_labels:
            allowed_labels.add("No Hit File")
        if "No Hit File" in allowed_labels:
            allowed_labels.add("No Hit")

        for label, path in tracker_data.items():
            if label not in allowed_labels:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                        print(f"üóëÔ∏è Deleted {label} at {path} (user requested not to keep).")
                except Exception as e:
                    print(f"‚ö†Ô∏è Failed to delete {path}: {e}")

        # Additionally, try to clean empty subfolders (best-effort)
        for folder in subfolders:
            folder_path = os.path.join(individual_output_folder, folder)
            try:
                if os.path.isdir(folder_path) and not os.listdir(folder_path):
                    os.rmdir(folder_path)
            except Exception:
                pass



    # //Funciton of Replacements of SkipTraced Files 


        # Replace SkipTraced with external version if available
    external_skiptraced_folder = os.path.join(output_folder, "SkipTraced")
    replace_skiptraced_file(list_name, individual_output_folder, external_skiptraced_folder)





    


    return [filepath_01, filepath_02, filepath_03, filepath_04, filepath_05, no_hit_path]

# -------------------------------
# PROCESS DIRECTORY
# -------------------------------
def process_directory(input_folder):
    output_folder = os.path.join(input_folder, "Processed")
    ensure_folder(output_folder)

    for filename in os.listdir(input_folder):
        if filename.lower().endswith(('.csv', '.xlsx')):
            input_path = os.path.join(input_folder, filename)
            list_name = os.path.splitext(filename)[0]
            print(f"‚ö° Processing {filename} ...")
            try:
                run_pipeline(input_path, list_name, input_folder)  # Pass input_folder as output_folder
            except Exception as e:
                print(f"‚ùå Failed on {filename}: {e}")

# -------------------------------
# CC Ready File Processor
# -------------------------------
def process_individual_cc_ready_file(file_path):
    return remove_type_columns_from_cc_ready(file_path)
#SkipTraced File Replacements


#--------------------------------------#







import shutil

def replace_skiptraced_file(list_name, individual_output_folder, external_skiptraced_folder):
    """
    Replace the generated SkipTraced file with the one from external SkipTraced folder
    if a matching file exists.
    """
    try:
        external_file = os.path.join(external_skiptraced_folder, f"{list_name}.xlsx")
        output_skiptraced_folder = os.path.join(individual_output_folder, "SkipTraced")
        output_file = os.path.join(output_skiptraced_folder, f"{list_name}.xlsx")

        if os.path.exists(external_file):
            if os.path.exists(output_file):
                os.remove(output_file)
                print(f"üóëÔ∏è Deleted generated SkipTraced: {output_file}")
            shutil.copy2(external_file, output_file)
            print(f"‚úÖ Replaced SkipTraced with external file: {external_file}")
        else:
            print(f"‚ÑπÔ∏è No external SkipTraced file found for: {list_name}")
    except Exception as e:
        print(f"‚ùå Error replacing SkipTraced file for {list_name}: {e}")







#--------------------------------------#






# -------------------------------
# Main
# -------------------------------
if __name__ == "__main__":
    print("Pipeline Script Loaded")
    print("Available functions:")
    print("- process_directory(input_folder)")
    print("- run_pipeline(input_path, list_name, output_folder, keep_outputs=None)")
    print("- process_individual_cc_ready_file(file_path)")

Previous File main02.py:

import os
import tkinter as tk
import ttkbootstrap as tb
from tkinter import filedialog, ttk

from main.main import HitrotechApp, TOOL_DEFS  # Import base app + tools
# from logs import report_summary_logs
# from logs.report_summary_logs import logger, log_tool_usage, open_today_report_folder

import subprocess
import pandas as pd
import threading

# Import the new subtractor script
from utils.records_subtractor import subtract_records, subtract_folders

# -----------------------------
# Extended Application
# -----------------------------
class ExtendedApp(HitrotechApp):
    def __init__(self, root):
        super().__init__(root)

    # ---- File Records Subtractor Tool
    def action_file_subtractor(self):
        win = tb.Toplevel(self.root)
        win.title("File Records Subtractor")
        win.geometry("1000x800")  # Increased width to accommodate side-by-side layout
        
        # Use a regular tkinter Frame for the background
        main_frame = tk.Frame(win, bg="#fff3e0")
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create canvas and scrollbar
        canvas = tk.Canvas(main_frame, bg="#fff3e0")
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#fff3e0")
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Create a container frame for side-by-side layout
        side_by_side_frame = tk.Frame(scrollable_frame, bg="#fff3e0")
        side_by_side_frame.pack(fill="x", padx=10, pady=5)
        
        # Left side files selection
        left_frame = tb.LabelFrame(side_by_side_frame, text="Left Side Files (Records to keep)", bootstyle="primary", width=450)
        left_frame.pack(side="left", fill="both", expand=True, padx=(0, 5))
        
        tb.Label(left_frame, text="Select files containing records to keep (subtract from)").pack(pady=5)
        
        left_files_frame = tk.Frame(left_frame)
        left_files_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        left_files_listbox = tk.Listbox(left_files_frame, height=6, selectmode=tk.EXTENDED)
        left_scrollbar = ttk.Scrollbar(left_files_frame, orient="vertical", command=left_files_listbox.yview)
        left_files_listbox.configure(yscrollcommand=left_scrollbar.set)
        
        left_files_listbox.pack(side="left", fill="both", expand=True)
        left_scrollbar.pack(side="right", fill="y")
        
        left_btn_frame = tb.Frame(left_frame)
        left_btn_frame.pack(fill="x", padx=5, pady=5)
        
        def add_left_files():
            files = filedialog.askopenfilenames(
                title="Select Left Side Files",
                filetypes=[("CSV Files", "*.csv"), ("Excel Files", "*.xlsx"), ("All Files", "*.*")]
            )
            for file in files:
                left_files_listbox.insert(tk.END, file)
            update_column_lists()
        
        def remove_left_files():
            selected_indices = left_files_listbox.curselection()
            for index in selected_indices[::-1]:
                left_files_listbox.delete(index)
            update_column_lists()
        
        tb.Button(left_btn_frame, text="Add Files", bootstyle="secondary", 
                 command=add_left_files).pack(side="left", padx=5)
        tb.Button(left_btn_frame, text="Remove Selected", bootstyle="danger", 
                 command=remove_left_files).pack(side="left", padx=5)
        tb.Button(left_btn_frame, text="Clear All", bootstyle="warning", 
                 command=lambda: left_files_listbox.delete(0, tk.END)).pack(side="left", padx=5)
        
        tb.Label(left_frame, text="Combine columns (comma-separated):").pack(pady=5)
        left_columns_var = tk.StringVar()
        left_columns_entry = tb.Combobox(left_frame, textvariable=left_columns_var, width=40)
        left_columns_entry.pack(pady=5)
        
        # Right side files selection - shifted to the right
        right_frame = tb.LabelFrame(side_by_side_frame, text="Right Side Files (Records to subtract)", bootstyle="danger", width=450)
        right_frame.pack(side="right", fill="both", expand=True, padx=(5, 0))
        
        tb.Label(right_frame, text="Select files containing records to subtract").pack(pady=5)
        
        right_files_frame = tk.Frame(right_frame)
        right_files_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        right_files_listbox = tk.Listbox(right_files_frame, height=6, selectmode=tk.EXTENDED)
        right_scrollbar = ttk.Scrollbar(right_files_frame, orient="vertical", command=right_files_listbox.yview)
        right_files_listbox.configure(yscrollcommand=right_scrollbar.set)
        
        right_files_listbox.pack(side="left", fill="both", expand=True)
        right_scrollbar.pack(side="right", fill="y")
        
        right_btn_frame = tb.Frame(right_frame)
        right_btn_frame.pack(fill="x", padx=5, pady=5)
        
        def add_right_files():
            files = filedialog.askopenfilenames(
                title="Select Right Side Files",
                filetypes=[("CSV Files", "*.csv"), ("Excel Files", "*.xlsx"), ("All Files", "*.*")]
            )
            for file in files:
                right_files_listbox.insert(tk.END, file)
            update_column_lists()
        
        def remove_right_files():
            selected_indices = right_files_listbox.curselection()
            for index in selected_indices[::-1]:
                right_files_listbox.delete(index)
            update_column_lists()
        
        tb.Button(right_btn_frame, text="Add Files", bootstyle="secondary", 
                 command=add_right_files).pack(side="left", padx=5)
        tb.Button(right_btn_frame, text="Remove Selected", bootstyle="danger", 
                 command=remove_right_files).pack(side="left", padx=5)
        tb.Button(right_btn_frame, text="Clear All", bootstyle="warning", 
                 command=lambda: right_files_listbox.delete(0, tk.END)).pack(side="left", padx=5)
        
        tb.Label(right_frame, text="Combine columns (comma-separated):").pack(pady=5)
        right_columns_var = tk.StringVar()
        right_columns_entry = tb.Combobox(right_frame, textvariable=right_columns_var, width=40)
        right_columns_entry.pack(pady=5)
        
        # Mapping visualization frame
        mapping_frame = tb.LabelFrame(scrollable_frame, text="Column Mapping Visualization", bootstyle="info")
        mapping_frame.pack(fill="x", padx=10, pady=10)
        
        mapping_canvas = tk.Canvas(mapping_frame, height=100, bg="white", highlightthickness=1, highlightbackground="#ccc")
        mapping_canvas.pack(fill="x", padx=5, pady=5)
        
        left_mapping_text = mapping_canvas.create_text(150, 30, text="Left Columns: Not set", font=("Arial", 10), fill="blue")
        right_mapping_text = mapping_canvas.create_text(150, 70, text="Right Columns: Not set", font=("Arial", 10), fill="red")
        mapping_status = mapping_canvas.create_text(450, 50, text="Mapping Status: Not configured", font=("Arial", 10, "bold"), fill="orange")
        
        def update_mapping_display():
            left_cols = left_columns_var.get()
            right_cols = right_columns_var.get()
            
            mapping_canvas.itemconfig(left_mapping_text, text=f"Left Columns: {left_cols if left_cols else 'Not set'}")
            mapping_canvas.itemconfig(right_mapping_text, text=f"Right Columns: {right_cols if right_cols else 'Not set'}")
            
            if left_cols and right_cols:
                mapping_canvas.itemconfig(mapping_status, text="Mapping Status: ‚úÖ Ready to subtract", fill="green")
            elif left_cols or right_cols:
                mapping_canvas.itemconfig(mapping_status, text="Mapping Status: ‚ö†Ô∏è Partial configuration", fill="orange")
            else:
                mapping_canvas.itemconfig(mapping_status, text="Mapping Status: ‚ùå Not configured", fill="red")
        
        # Bind the update function to column entry changes
        left_columns_var.trace("w", lambda *args: update_mapping_display())
        right_columns_var.trace("w", lambda *args: update_mapping_display())
        
        # Function to update column lists from files
        def update_column_lists():
            try:
                # Get columns from first left file if available
                left_files = left_files_listbox.get(0, tk.END)
                if left_files:
                    file = left_files[0]
                    if file.endswith('.csv'):
                        df = pd.read_csv(file, nrows=1)
                    else:
                        df = pd.read_excel(file, nrows=1)
                    left_cols = list(df.columns)
                    left_columns_entry['values'] = left_cols
                
                # Get columns from first right file if available
                right_files = right_files_listbox.get(0, tk.END)
                if right_files:
                    file = right_files[0]
                    if file.endswith('.csv'):
                        df = pd.read_csv(file, nrows=1)
                    else:
                        df = pd.read_excel(file, nrows=1)
                    right_cols = list(df.columns)
                    right_columns_entry['values'] = right_cols
                    
            except Exception as e:
                print(f"Error reading column names: {e}")
        
        # Output options
        output_frame = tb.LabelFrame(scrollable_frame, text="Output Options", bootstyle="success")
        output_frame.pack(fill="x", padx=10, pady=5)
        
        output_name_frame = tb.Frame(output_frame)
        output_name_frame.pack(fill="x", padx=5, pady=5)
        
        tb.Label(output_name_frame, text="Output file name:").pack(side="left")
        output_name_var = tk.StringVar(value="Records_Minus")
        tb.Entry(output_name_frame, textvariable=output_name_var, width=30).pack(side="left", padx=10)
        
        output_format_var = tk.StringVar(value="xlsx")
        format_frame = tb.Frame(output_name_frame)
        format_frame.pack(side="left", padx=20)
        tb.Label(format_frame, text="Format:").pack(side="left")
        tb.Radiobutton(format_frame, text="Excel", variable=output_format_var, value="xlsx", bootstyle="success").pack(side="left", padx=5)
        tb.Radiobutton(format_frame, text="CSV", variable=output_format_var, value="csv", bootstyle="success").pack(side="left", padx=5)
        
        output_folder_frame = tb.Frame(output_frame)
        output_folder_frame.pack(fill="x", padx=5, pady=5)
        
        tb.Label(output_folder_frame, text="Output folder:").pack(side="left")
        output_folder_var = tk.StringVar(value=os.path.join(os.getcwd(), "output"))
        tb.Entry(output_folder_frame, textvariable=output_folder_var, width=40).pack(side="left", padx=10)
        
        def browse_output_folder():
            folder = filedialog.askdirectory()
            if folder:
                output_folder_var.set(folder)
        
        tb.Button(output_folder_frame, text="Browse", bootstyle="secondary", 
                 command=browse_output_folder).pack(side="left", padx=5)
        
        # Progress bar
        progress_frame = tb.Frame(scrollable_frame)
        progress_frame.pack(fill="x", padx=10, pady=10)
        
        progress_var = tk.DoubleVar()
        progress_bar = tb.Progressbar(progress_frame, variable=progress_var, maximum=100, bootstyle="success-striped")
        progress_bar.pack(fill="x", pady=5)
        
        progress_label = tb.Label(progress_frame, text="Ready", font=("Arial", 9))
        progress_label.pack()
        
        # Run button
        def run_subtraction():
            left_files = left_files_listbox.get(0, tk.END)
            right_files = right_files_listbox.get(0, tk.END)
            
            if not left_files:
                self.ui.show_error("‚ùå Error", "Please select at least one left side file")
                return
            
            if not right_files:
                self.ui.show_error("‚ùå Error", "Please select at least one right side file")
                return
            
            left_columns = [col.strip() for col in left_columns_var.get().split(",") if col.strip()]
            right_columns = [col.strip() for col in right_columns_var.get().split(",") if col.strip()]
            
            if not left_columns:
                self.ui.show_error("‚ùå Error", "Please specify columns to combine for left side files")
                return
            
            if not right_columns:
                self.ui.show_error("‚ùå Error", "Please specify columns to combine for right side files")
                return
            
            output_folder = output_folder_var.get()
            if not output_folder:
                self.ui.show_error("‚ùå Error", "Please select an output folder")
                return
            
            os.makedirs(output_folder, exist_ok=True)
            
            output_name = output_name_var.get()
            if not output_name:
                output_name = "Records_Minus"
            
            output_format = output_format_var.get()
            output_path = os.path.join(output_folder, f"{output_name}.{output_format}")
            
            def work():
                try:
                    progress_var.set(10)
                    progress_label.config(text="Starting subtraction...")
                    
                    # Use the standalone subtractor function
                    subtract_records(
                        left_files=list(left_files),
                        right_files=list(right_files),
                        left_columns=left_columns,
                        right_columns=right_columns,
                        output_path=output_path,
                        output_format=output_format
                    )
                    
                    progress_var.set(100)
                    progress_label.config(text="‚úÖ Subtraction completed!")
                    
                    self.ui.show_info("‚úÖ Success", f"Subtraction completed. Result saved to:\n{output_path}")
                    
                except Exception as e:
                    progress_label.config(text="‚ùå Error occurred!")
                    self.ui.show_error("‚ùå Error", f"An error occurred during subtraction:\n{str(e)}")
            
            # Run in a separate thread
            thread = threading.Thread(target=work)
            thread.daemon = True
            thread.start()
        
        action_frame = tb.Frame(scrollable_frame)
        action_frame.pack(pady=10)
        
        tb.Button(action_frame, text="üîÑ Update Column Lists", bootstyle="info", 
                 command=update_column_lists).pack(side="left", padx=5)
        tb.Button(action_frame, text="‚ûñ Subtract Files", bootstyle="success", 
                 command=run_subtraction, width=20).pack(side="left", padx=5)
        
        # Initialize
        update_mapping_display()

    # ---- Vacant Lot 6 Phone Numbers Tool
    def action_vacant_lot_6_phone(self):
        win = tb.Toplevel(self.root)
        win.title("Vacant Lot ‚Äî  Phone Numbers")
        win.geometry("560x420")
        
        # Use regular tkinter Frame for background
        main_frame = tk.Frame(win, bg="#fff3e0")
        main_frame.pack(fill="both", expand=True)

        tb.Label(main_frame, text="Input Folder (CSV or XLSX files)", font=("Segoe UI", 12, "bold"), background="#fff3e0").pack(pady=8)
        input_var = tk.StringVar()

        def browse_input():
            folder = filedialog.askdirectory()
            if folder:
                input_var.set(folder)

        frame_in = tb.Frame(main_frame)
        frame_in.pack(pady=4)
        tb.Entry(frame_in, textvariable=input_var, width=52).pack(side="left", padx=5)
        tb.Button(frame_in, text="Browse", bootstyle="secondary", command=browse_input).pack(side="left")

        tb.Label(main_frame, text="Output folder (Processed will be created inside)", font=("Segoe UI", 10), background="#fff3e0").pack(pady=6)
        out_var = tk.StringVar(value=os.path.join(os.getcwd(), "output"))
        frame_out = tb.Frame(main_frame)
        frame_out.pack(pady=4)
        tb.Entry(frame_out, textvariable=out_var, width=42).pack(side="left", padx=5)

        def browse_out():
            d = filedialog.askdirectory()
            if d:
                out_var.set(d)

        tb.Button(frame_out, text="Browse", bootstyle="secondary", command=browse_out).pack(side="left")

        # Checkboxes for outputs ‚Äî default checked
        tb.Label(main_frame, text="Which output files do you WANT to KEEP? (checked = keep)", font=("Segoe UI", 10), background="#fff3e0").pack(pady=8)

        output_labels = ["SkipTraced", "2BSkip", "CC Ready", "SC Ready", "GHL Ready", "No Hit"]
        checkbox_vars = {}
        cb_frame = tb.Frame(main_frame)
        cb_frame.pack(pady=4)
        for lbl in output_labels:
            var = tk.BooleanVar(value=True)
            checkbox_vars[lbl] = var
            tb.Checkbutton(cb_frame, text=lbl, variable=var, bootstyle="round-toggle").pack(anchor="w")

        def run_vacant():
            input_folder = input_var.get().strip()
            if not input_folder or not os.path.isdir(input_folder):
                self.ui.show_error("‚ùå Error", "Please select a valid input folder")
                return

            out_folder = out_var.get().strip()
            if not out_folder:
                self.ui.show_error("‚ùå Error", "Please select an output folder")
                return

            keep_list = [lbl for lbl, v in checkbox_vars.items() if v.get()]

            def work():
                try:
                    for file in os.listdir(input_folder):
                        if file.endswith(".csv") or file.endswith(".xlsx"):
                            file_path = os.path.join(input_folder, file)
                            list_name = os.path.splitext(os.path.basename(file))[0]
                            self.utils['run_vacant_6_pipeline'](
                                file_path, list_name, out_folder, keep_outputs=keep_list
                            )
                    self.ui.show_info("‚úÖ Done", "Vacant Lot pipeline finished for all files.")
                except Exception as e:
                    self.ui.show_error("‚ùå Error", f"Pipeline failed: {e}")

            self.run_with_loader(work)

        tb.Button(main_frame, text="Start List Building", bootstyle="success", command=run_vacant, width=28).pack(pady=14)

    # ---- Extend handlers
    def get_action_handlers(self):
        handlers = super().get_action_handlers()
        handlers['vacant6'] = self.action_vacant_lot_6_phone
        handlers['filesubtractor'] = self.action_file_subtractor
        return handlers


# -----------------------------
# Add tool definition for Vacant Lot and File Subtractor
# -----------------------------
TOOL_DEFS.append({
    'key': 'vacant6',
    'title': 'Land Data Builder',
    'desc': 'Generate vacant lot lists with up to 6 phone numbers',
    'icon': 'üåø',
    'action_text': 'Run',
})

TOOL_DEFS.append({
    'key': 'filesubtractor',
    'title': 'Record Subtractor',
    'desc': 'Compare datasets and remove overlapping records',
    'icon': '‚ûñ',
    'action_text': 'Open',
})


