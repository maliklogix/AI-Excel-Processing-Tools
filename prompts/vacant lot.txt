I want to add new tool name;
Vacant Lot 6 Phone Numbers;
My folder structure is:
pipeline\vacant_lot_pipeline/6_phone_number_vacant_lot.py
main/main.py
run.py
---Requirements
Have a UI which have main dashboard with 
multiple options like Checkbox bydefault Check
which files want in output if uncheck the file will
generated and after that it will deleted from the folder
----
main.py file: where new tool will be added  by Name vacant lot 6 phone
---Remember a already tool of 6 phone is exists and it's script is similar donot messup
main.py file is:




import os
import threading
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog

# Third-party UI theme
import ttkbootstrap as tb
from ttkbootstrap.constants import *

from ui.ui_main import HitrotechUI
from utils.merger import open_merger_tool


# -----------------------------
# Helpers: Safe/late imports of project modules (keeps this file standalone)
# -----------------------------

def _try_import(path, name):
    """Import a symbol (function/module) from a dotted path safely.
    path like "utils.converters", name like "csv_to_excel".
    Returns callable/module or raises helpful messagebox at call-time.
    """
    try:
        module = __import__(path, fromlist=[name])
        return getattr(module, name)
    except Exception as e:
        def _missing(*args, **kwargs):
            messagebox.showerror(
                "Missing dependency",
                f"Could not import {name} from {path}.\n\nError: {e}\n\n"
                "Make sure your project files are available or adjust TOOL_DEFS to your setup."
            )
        return _missing

# Lazily resolved callables (evaluated inside actions)

def get_utils():
    return {
        'csv_to_excel': _try_import('utils.converters', 'csv_to_excel'),
        'excel_to_csv': _try_import('utils.converters', 'excel_to_csv'),
        'merge_files': _try_import('utils.merger', 'merge_files'),
        'separate_by_column': _try_import('utils.separator', 'separate_by_column'),
        'run_step05_pipeline': _try_import('utils.ghl_compiler', 'run_step05_pipeline'),
        'run_column_mapper': _try_import('utils.column_mapper', 'run_column_mapper'),
        'run_script1': _try_import('utils.readRecords_campaignReady_driveReady', 'run_script1'),
        'run_script2': _try_import('utils.readRecords_campaignReady_driveReady', 'run_script2'),
        'run_script3': _try_import('utils.readRecords_campaignReady_driveReady', 'run_script3'),
        'process_directory': _try_import('pipeline.listbuilding_pipeline', 'process_directory'),
        'run_pipeline': _try_import('pipeline.listbuilding_pipeline', 'run_pipeline'),
        'process_aae_directory': _try_import('pipeline.AAE_3_phone_lsb', 'process_aae_directory'),
        'run_aae_pipeline': _try_import('pipeline.AAE_3_phone_lsb', 'run_aae_pipeline'),
        'run_column_adder': _try_import('utils.gen_coloumns_adder', 'run_column_adder'),
        'run_record_collector': _try_import('utils.record_collector', 'run_record_collector'),
    }

# -----------------------------
# Application logic
# -----------------------------
class HitrotechApp:
    
    def __init__(self, root):
        self.root = root
        self.utils = get_utils()
        self.ui = None
        self.setup_app()

    # ///////////// Always on TOP 
    # Utility to open any tool in always-on-top Toplevel
    def open_tool_window(self, tool_func):
        """
        Wraps a tool in a Toplevel that stays always on top
        :param tool_func: function(tool_window, ui) -> None
        """
        win = tk.Toplevel(self.root)
        win.attributes("-topmost", True)  # keep window on top
        tool_func(win, self.ui)
        return win
    # /////////////

    def action_record_collector(self):
        win = tb.Toplevel(self.root)
        win.title("Record Collector Tool")
        win.geometry("520x420")
        win.configure(bg="#fff3e0")

        tb.Label(win, text="Select Base Directory", font=("Segoe UI", 12, "bold"), background="#fff3e0").pack(pady=10)

        path_var = tk.StringVar()

        def browse_folder():
            folder = filedialog.askdirectory()
            if folder:
                path_var.set(folder)

        frame_path = tb.Frame(win)
        frame_path.pack(pady=5)
        tb.Entry(frame_path, textvariable=path_var, width=42).pack(side="left", padx=5)
        tb.Button(frame_path, text="Browse", bootstyle="secondary", command=browse_folder).pack(side="left")

        tb.Label(win, text="Select Folder Type:", font=("Segoe UI", 10), background="#fff3e0").pack(pady=10)

        predefined = ["GHL Ready", "SkipTraced", "2BSkip", "CC Ready", "No Hit", "SC Ready"]
        folder_var = tk.StringVar(value=predefined[0])

        # Dropdown for predefined + custom input
        folder_menu = tb.Combobox(win, textvariable=folder_var, values=predefined, width=40)
        folder_menu.pack(pady=5)

        tb.Label(win, text="Or enter custom folder name:", font=("Segoe UI", 10), background="#fff3e0").pack(pady=6)
        custom_var = tk.StringVar()
        tb.Entry(win, textvariable=custom_var, width=42).pack(pady=5)

        def run_collector():
            base = path_var.get().strip()
            if not base or not os.path.isdir(base):
                self.ui.show_error("‚ùå Error", "Please select a valid base folder")
                return

            folder_name = custom_var.get().strip() or folder_var.get()
            if not folder_name:
                self.ui.show_error("‚ùå Error", "Please select or enter a folder name")
                return

            def work():
                self.utils['run_record_collector'](base, folder_name)
                self.ui.show_info("‚úÖ Done", f"Files collected for '{folder_name}'")

            self.run_with_loader(work)

        tb.Button(win, text="Run Collector", bootstyle="success", command=run_collector, width=22).pack(pady=14)
   
    def setup_app(self):
        # Create UI with tool definitions and action handlers
        self.ui = HitrotechUI(self.root, TOOL_DEFS, self.get_action_handlers())
        
    def get_action_handlers(self):
        return {
            'recordcollector': self.action_record_collector,
            'csv2xlsx': self.action_csv_to_excel,
            'xlsx2csv': self.action_excel_to_csv,
            'merge': self.action_merge,
            'separator': self.action_separate,
            'ghl': self.action_ghl,
            'mapper': self.action_column_mapper,
            'records': self.action_records_extractor,
            'pipeline': self.action_pipeline_bulk,
            'aae': self.action_aae_3_phone_lsb,
            'coladder': self.action_column_adder,
        }
    
    def run_with_loader(self, func, *args, **kwargs):
        popup, prog = self.ui.show_loading()

        def task():
            try:
                func(*args, **kwargs)
            finally:
                self.root.after(0, popup.destroy)

        threading.Thread(target=task, daemon=True).start()

    # -----------------------------
    # Actions (each is self-contained and resilient to missing project files)
    # -----------------------------

    def action_csv_to_excel(self):
        files = self.ui.select_files([("CSV Files", "*.csv")])
        if not files:
            return
        out = self.ui.select_folder()
        if not out:
            return

        def work():
            ok = 0
            for f in files:
                self.utils['csv_to_excel'](f, out)
                ok += 1
            self.ui.show_info("‚úÖ Success", f"Converted {ok} CSV file(s) to Excel.")

        self.run_with_loader(work)

    def action_excel_to_csv(self):
        files = self.ui.select_files([("Excel Files", "*.xlsx")])
        if not files:
            return
        out = os.path.join(os.getcwd(), "output", "csv")
        os.makedirs(out, exist_ok=True)

        def work():
            ok = 0
            for f in files:
                self.utils['excel_to_csv'](f, out)
                ok += 1
            self.ui.show_info("‚úÖ Success", f"Converted {ok} Excel file(s) to CSV (folder: {out}).")

        self.run_with_loader(work)

    def action_merge(self):
        open_merger_tool(self.root, self.ui)

    def action_separate(self):
        file = filedialog.askopenfilename(filetypes=[("Excel/CSV Files", "*.xlsx *.csv")])
        if not file:
            return
        col = self.ui.ask_string("Column Name", "Enter column to split by:")
        if not col:
            return

        def work():
            self.utils['separate_by_column'](file, col)
            self.ui.show_info("‚úÖ Success", f"Separated files by {col}")

        self.run_with_loader(work)

    def action_column_adder(self):
        # Call the function from gen_coloumns_adder
        self.utils['run_column_adder'](self.root)

    def action_ghl(self):
        files = self.ui.select_files([("Excel/CSV Files", "*.xlsx *.csv")])
        if not files:
            return

        def work():
            for f in files:
                self.utils['run_step05_pipeline'](f)
            self.ui.show_info("‚úÖ Success", "GHL Ready files created")

        self.run_with_loader(work)

    def action_column_mapper(self):
        file = filedialog.askopenfilename(filetypes=[("Excel/CSV Files", "*.xlsx *.csv")])
        if file:
            self.utils['run_column_mapper'](file)

    # ---- Records Extractor (subwindow)

    def action_records_extractor(self):
        win = tb.Toplevel(self.root)
        win.title("Records Extractor Tool")
        win.geometry("520x420")
        win.configure(bg="#fff3e0")

        tb.Label(win, text="Select Folder to Process", font=("Segoe UI", 12, "bold"), background="#fff3e0").pack(pady=10)

        path_var = tk.StringVar()

        def browse_folder():
            folder = filedialog.askdirectory()
            if folder:
                path_var.set(folder)

        frame_path = tb.Frame(win)
        frame_path.pack(pady=5)
        tb.Entry(frame_path, textvariable=path_var, width=42).pack(side="left", padx=5)
        tb.Button(frame_path, text="Browse", bootstyle="secondary", command=browse_folder).pack(side="left")

        tb.Label(win, text="Select Operation:", font=("Segoe UI", 10), background="#fff3e0").pack(pady=10)

        script_var = tk.StringVar(value="run_all")
        options_frame = tb.Frame(win, bootstyle="light")
        options_frame.pack(pady=5)

        tb.Radiobutton(options_frame, text="Run All Operations", variable=script_var, value="run_all", bootstyle="primary-toolbutton").pack(anchor="w", pady=5)
        tb.Radiobutton(options_frame, text="Extract Records from TXT/CSV", variable=script_var, value="script1", bootstyle="primary-toolbutton").pack(anchor="w", pady=5)
        tb.Radiobutton(options_frame, text="Collect GHL Ready Files & Create Zip", variable=script_var, value="script2", bootstyle="primary-toolbutton").pack(anchor="w", pady=5)
        tb.Radiobutton(options_frame, text="Organize Folders Structure", variable=script_var, value="script3", bootstyle="primary-toolbutton").pack(anchor="w", pady=5)

        def run_selected_script():
            folder = path_var.get().strip()
            if not folder or not os.path.isdir(folder):
                self.ui.show_error("‚ùå Error", "Please select a valid folder path")
                return

            def work():
                original_dir = os.getcwd()
                os.chdir(folder)
                try:
                    if script_var.get() == "script1":
                        self.utils['run_script1']()
                        self.ui.show_info("‚úÖ Success", "Records extracted successfully!")
                    elif script_var.get() == "script2":
                        self.utils['run_script2']()
                        self.ui.show_info("‚úÖ Success", "GHL Ready files collected and zip created!")
                    elif script_var.get() == "script3":
                        self.utils['run_script3']()
                        self.ui.show_info("‚úÖ Success", "Folders organized successfully!")
                    else:
                        self.utils['run_script1'](); self.utils['run_script2'](); self.utils['run_script3']()
                        self.ui.show_info("‚úÖ Success", "All operations completed successfully!")
                except Exception as e:
                    self.ui.show_error("‚ùå Error", f"An error occurred: {e}")
                finally:
                    os.chdir(original_dir)

            self.run_with_loader(work)

        tb.Button(win, text="Run Selected Operation", bootstyle="success", command=run_selected_script, width=26).pack(pady=16)

    # ---- Pipeline (bulk) subwindow

    def action_pipeline_bulk(self):
        win = tb.Toplevel(self.root)
        win.title("Pipeline ListBuilding Bulk")
        win.geometry("520x300")
        win.configure(bg="#fff3e0")

        tb.Label(win, text="Select Input Folder", font=("Segoe UI", 12, "bold"), background="#fff3e0").pack(pady=10)

        path_var = tk.StringVar()

        def browse_folder():
            folder = filedialog.askdirectory()
            if folder:
                path_var.set(folder)

        frame_path = tb.Frame(win)
        frame_path.pack(pady=5)
        tb.Entry(frame_path, textvariable=path_var, width=42).pack(side="left", padx=5)
        tb.Button(frame_path, text="Browse", bootstyle="secondary", command=browse_folder).pack(side="left")

        step05_var = tk.BooleanVar(value=True)
        tb.Checkbutton(win, text="Include Step05 (GHL Ready)", variable=step05_var, bootstyle="round-toggle").pack(pady=14)

        def run_bulk():
            folder = path_var.get().strip()
            if not folder or not os.path.isdir(folder):
                self.ui.show_error("‚ùå Error", "Please select a valid folder path")
                return

            def work():
                if not step05_var.get():
                    import importlib
                    pl = importlib.import_module('pipeline.listbuilding_pipeline')
                    orig = getattr(pl, 'step_05_reshape', lambda df: df)
                    setattr(pl, 'step_05_reshape', lambda df: df)
                    self.utils['process_directory'](folder)
                    setattr(pl, 'step_05_reshape', orig)
                else:
                    self.utils['process_directory'](folder)
                self.ui.show_info("‚úÖ Done", "Pipeline processing complete.")

            self.run_with_loader(work)

        tb.Button(win, text="Run Pipeline", bootstyle="success", command=run_bulk, width=20).pack(pady=12)

    # ---- AAE 3 Phone LSB subwindow

    def action_aae_3_phone_lsb(self):
        win = tb.Toplevel(self.root)
        win.title("AAE 3 Phone LSB")
        win.geometry("520x290")
        win.configure(bg="#fff3e0")

        tb.Label(win, text="Select Input Folder", font=("Segoe UI", 12, "bold"), background="#fff3e0").pack(pady=10)

        path_var = tk.StringVar()

        def browse_folder():
            folder = filedialog.askdirectory()
            if folder:
                path_var.set(folder)

        frame_path = tb.Frame(win)
        frame_path.pack(pady=5)
        tb.Entry(frame_path, textvariable=path_var, width=42).pack(side="left", padx=5)
        tb.Button(frame_path, text="Browse", bootstyle="secondary", command=browse_folder).pack(side="left")

        step01_var = tk.BooleanVar(value=False)
        tb.Checkbutton(win, text="Process Step01 Files (Skip Step01 processing)", variable=step01_var, bootstyle="round-toggle").pack(pady=14)

        def run_aae():
            folder = path_var.get().strip()
            if not folder or not os.path.isdir(folder):
                self.ui.show_error("‚ùå Error", "Please select a valid folder path")
                return

            def work():
                self.utils['process_aae_directory'](folder, process_step01_files=step01_var.get())
                self.ui.show_info("‚úÖ Done", "AAE 3 Phone LSB processing complete.")

            self.run_with_loader(work)

        tb.Button(win, text="Run AAE 3 Phone LSB", bootstyle="success", command=run_aae, width=22).pack(pady=12)


# -----------------------------
# Tool definitions (add here; UI updates automatically)
# -----------------------------
TOOL_DEFS = [
    {
        'key': 'csv2xlsx',
        'title': 'CSV ‚Üí Excel Converter',
        'desc': 'Convert one or more CSV files into XLSX format in a chosen folder.',
        'icon': 'üìÑ',
        'action_text': 'Convert',
    },
    {
        'key': 'xlsx2csv',
        'title': 'Excel ‚Üí CSV Converter',
        'desc': 'Export Excel workbooks as CSV files into an automatic output folder.',
        'icon': 'üì§',
        'action_text': 'Export',
    },

    {
        'key': 'merge',
        'title': 'Merge CSV/Excel Files',
        'desc': 'Combine multiple CSV/XLSX files into a single merged workbook.',
        'icon': 'üß©',
        'action_text': 'Merge',
    },
    {
        'key': 'separator',
        'title': 'File Separator (by Column)',
        'desc': 'Split a file into multiple files based on a column\'s unique values.',
        'icon': '‚úÇÔ∏è',
        'action_text': 'Separate',
    },
    {
        'key': 'ghl',
        'title': 'GHL Ready Compiler',
        'desc': 'Run Step05 pipeline to create GHL Ready files from your inputs.',
        'icon': '‚öôÔ∏è',
        'action_text': 'Compile',
    },
    {
        'key': 'mapper',
        'title': 'Column Mapper Tool',
        'desc': 'Open the interactive mapper to align columns to your standard.',
        'icon': 'üó∫Ô∏è',
        'action_text': 'Open',
    },
    {
        'key': 'records',
        'title': 'Records Extractor Tool',
        'desc': 'Extract records, collect GHL files into zip, or organize folders.',
        'icon': 'üîé',
        'action_text': 'Launch',
    },
    {
        'key': 'pipeline',
        'title': 'MCHB MPV / 6 Phones LSB',
        'desc': 'Bulk list-building pipeline with optional Step05 reshaping.',
        'icon': 'üì¶',
        'action_text': 'Run',
    },
    {
        'key': 'aae',
        'title': 'AAE 3 Phone LSB',
        'desc': 'Process AAE list-building with toggle for Step01 handling.',
        'icon': 'üì±',
        'action_text': 'Run',
    },
    {
        'key': 'coladder',
        'title': 'Column Adder in Output Folder',
        'desc': 'Map master columns to folder files and inject new columns with data.',
        'icon': '‚ûï',
        'action_text': 'Open',
    },
    {
        'key': 'recordcollector',
        'title': 'Record Collector Tool',
        'desc': 'Collect all files from predefined or custom folders into one main folder.',
        'icon': 'üìÇ',
        'action_text': 'Collect',
    },
]

# -----------------------------
# Run app
# -----------------------------
def run_app():
    root = tb.Window(themename="cosmo")
    app = HitrotechApp(root)
    root.mainloop()





------
6_phone_number_vacant_lot.py file is which will integrated with main.py file
import pandas as pd
import os
import re

# -------------------------------
# Helpers
# -------------------------------
def to_pascal_case(text):
    if pd.isna(text):
        return text
    return ' '.join(word.capitalize() for word in str(text).split())

def normalize_address(addr):
    if pd.isna(addr): return ""
    addr = str(addr).strip().lower()
    addr = re.sub(r"\s+", " ", addr)
    return addr

def ensure_folder(folder):
    if not os.path.exists(folder):
        os.makedirs(folder)

# -------------------------------
# STEP 03.5: Remove Type columns from CC Ready files
# -------------------------------
def remove_type_columns_from_cc_ready(file_path):
    """
    Remove Type1‚ÄìType6 columns from CC Ready files but KEEP Email
    """
    try:
        df = pd.read_excel(file_path)

        # Remove Type columns
        columns_to_remove = ['Type1', 'Type2', 'Type3', 'Type4', 'Type5', 'Type6']
        df = df.drop(columns=[col for col in columns_to_remove if col in df.columns], errors='ignore')

        # Save back
        writer = pd.ExcelWriter(file_path, engine='xlsxwriter')
        df.to_excel(writer, sheet_name='Sheet1', index=False)

        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        no_border_format = workbook.add_format({'border': 0})

        for col_num, value in enumerate(df.columns.values):
            worksheet.write(0, col_num, value, no_border_format)

        writer.close()
        print(f"‚úÖ Removed Type columns from: {file_path}")
        return df

    except Exception as e:
        print(f"‚ùå Error processing CC Ready file: {str(e)}")
        return None

# -------------------------------
# STEP 01
# -------------------------------
def step_01_clean_and_standardize(df, list_name):
    cleaned = df.rename(columns={
        'first_name': 'First Name',
        'last_name': 'Last Name',
        'associated_property_address_line_1': 'Property Address',
        'associated_property_address_city': 'Property City',
        'associated_property_address_state': 'Property State',
        'associated_property_address_zipcode': 'Property Zip',
        'primary_mailing_address': 'Mailing Address',
        'primary_mailing_city': 'Mailing City',
        'primary_mailing_state': 'Mailing State',
        'primary_mailing_zip': 'Mailing Zip',
        'phone_1': 'Phone1',
        'phone_2': 'Phone2',
        'phone_3': 'Phone3',
        'phone_4': 'Phone4',
        'phone_5': 'Phone5',
        'phone_6': 'Phone6',
        'phone_1_type': 'Type1',
        'phone_2_type': 'Type2',
        'phone_3_type': 'Type3',
        'phone_4_type': 'Type4',
        'phone_5_type': 'Type5',
        'phone_6_type': 'Type6',
        'email': 'Email'
    })

    cleaned['Mailing Address'] = cleaned['Mailing Address'].apply(to_pascal_case)
    cleaned['Mailing City'] = cleaned['Mailing City'].apply(to_pascal_case)

    columns_to_keep = [
        'First Name', 'Last Name',
        'Property Address', 'Property City', 'Property State', 'Property Zip',
        'Mailing Address', 'Mailing City', 'Mailing State', 'Mailing Zip',
        
        'Phone1', 'Type1', 'Phone2', 'Type2', 'Phone3', 'Type3',
        'Phone4', 'Type4', 'Phone5', 'Type5', 'Phone6', 'Type6' ,

        'Email',
    ]
    cleaned = cleaned[[col for col in columns_to_keep if col in cleaned.columns]]
    cleaned['List'] = list_name
    return cleaned

# -------------------------------
# STEP 02
# -------------------------------
def step_02_remove_phones(df):
    return df.drop(columns=[
        'Phone1','Type1','Phone2','Type2','Phone3','Type3',
        'Phone4','Type4','Phone5','Type5','Phone6','Type6','Email'
    ], errors='ignore')

# -------------------------------
# STEP 03
# -------------------------------
def step_03_dedupe_and_cleanup(df, list_name, output_folder=None):
    df = df.drop_duplicates()
    df['normalized_address'] = df['Property Address'].apply(normalize_address)
    df = df.drop_duplicates(subset=['normalized_address'])
    df = df.drop(columns=['normalized_address'], errors='ignore')

    mask_no_phones = df[[f'Phone{i}' for i in range(1,7) if f'Phone{i}' in df.columns]].isna().all(axis=1)
    df_no_hit = df[mask_no_phones].copy()

    if not df_no_hit.empty and output_folder:
        no_hit_folder = os.path.join(output_folder, "No Hit")
        ensure_folder(no_hit_folder)
        no_hit_path = os.path.join(no_hit_folder, f"{list_name}.xlsx")

        writer = pd.ExcelWriter(no_hit_path, engine='xlsxwriter')
        df_no_hit.to_excel(writer, sheet_name='Sheet1', index=False)

        workbook = writer.book
        worksheet = writer.sheets['Sheet1']
        no_border_format = workbook.add_format({'border': 0})

        for col_num, value in enumerate(df_no_hit.columns.values):
            worksheet.write(0, col_num, value, no_border_format)

        writer.close()
        print(f"üìÇ No Hit file created at: {no_hit_path}")

    df = df[~mask_no_phones]
    df['List'] = list_name
    return df

# -------------------------------
# STEP 04
# -------------------------------
def step_04_process_phones(df):
    df = df[df[[f'Phone{i}' for i in range(1, 7) if f'Phone{i}' in df.columns]].notna().any(axis=1)].copy()

    # Remove landlines
    for i in range(1, 7):
        phone_col = f'Phone{i}'
        type_col = f'Type{i}'
        if type_col in df.columns:
            df.loc[df[type_col].astype(str).str.lower() == 'landline', phone_col] = None

    # Core address columns (without Email)
    address_columns = [
        'First Name', 'Last Name',
        'Property Address', 'Property City', 'Property State', 'Property Zip',
        'Mailing Address', 'Mailing City', 'Mailing State', 'Mailing Zip'
    ]

    # Clean property zip
 
    if 'Property Zip' in df.columns:
        df['Property Zip'] = df['Property Zip'].astype(str).str.split('-').str[0]
        df['Property Zip'] = pd.to_numeric(df['Property Zip'], errors='coerce').fillna(0).astype(int)
        # df['Property Zip'] = df['Property Zip'].astype(str)   # ‚úÖ convert back to text for GoHighLevel
 
    # Separate rows where first 3 phones are blank ‚Üí shift 4‚Äì6
    mask_blank_first3 = df[['Phone1', 'Phone2', 'Phone3']].isna().all(axis=1)
    df_4_2 = df[mask_blank_first3].copy()

    if not df_4_2.empty:
        df_4_2_processed = df_4_2[address_columns + ['Email', 'Phone4', 'Phone5', 'Phone6', 'List']].copy()
        df_4_2_processed.rename(columns={'Phone4': 'Phone1', 'Phone5': 'Phone2', 'Phone6': 'Phone3'}, inplace=True)
        df_4_2 = df_4_2_processed[address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List']]
    else:
        df_4_2 = pd.DataFrame(columns=address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List'])

    # Keep rows with first 3 phones
    df[['Phone4', 'Phone5', 'Phone6']] = None
    df_4_1 = df[~mask_blank_first3].copy()
    df_4_1 = df_4_1[address_columns + ['Phone1', 'Phone2', 'Phone3', 'Email', 'List']].copy()

    # Combine and drop empties
    df_combined = pd.concat([df_4_1, df_4_2], ignore_index=True)
    df_combined = df_combined[df_combined[['Phone1', 'Phone2', 'Phone3']].notna().any(axis=1)]

    return df_combined

# -------------------------------
# STEP 05
# -------------------------------
def step_05_reshape(df):
    def extract_numeric_phone(phone):
        return phone  # keep as-is

    phone_cols = [col for col in df.columns if col.lower().startswith("phone")]

    output_rows = []
    for _, row in df.iterrows():
        record = {
            "First Name": row.get("First Name", ""),
            "Last Name": row.get("Last Name", ""),
            "Property Address": row.get("Property Address", ""),
            "Property City": row.get("Property City", ""),
            "Property State": row.get("Property State", ""),
            "Property Zip": row.get("Property Zip", ""),
            "Mailing Address": row.get("Mailing Address", ""),
            "Mailing City": row.get("Mailing City", ""),
            "Mailing State": row.get("Mailing State", ""),
            "Mailing Zip": row.get("Mailing Zip", ""),
            "Email": row.get("Email", ""),
            "List": row.get("List", "")
        }

        # collect valid phones
        phone_numbers = []
        for phone_col in phone_cols:
            val = row.get(phone_col, None)
            if pd.notna(val) and str(val).strip() not in ["", "nan", "none", "null", "0"]:
                phone_numbers.append(extract_numeric_phone(val))

        if not phone_numbers:
            continue

        for phone in phone_numbers:
            rec_copy = record.copy()
            # Force final order: Phone ‚Üí Email ‚Üí List
            rec_copy = {
                **{k: rec_copy[k] for k in rec_copy if k not in ["Email", "List"]},
                "Phone": phone,
                "Email": rec_copy["Email"],
                "List": rec_copy["List"]
            }
            output_rows.append(rec_copy)

    return pd.DataFrame(output_rows)

# -------------------------------
# Save helper
# -------------------------------
def save_to_folder(df, folder, list_name, suffix=""):
    ensure_folder(folder)
    filepath = os.path.join(folder, f"{list_name}{suffix}.xlsx")
    df = df.fillna('')

    writer = pd.ExcelWriter(filepath, engine='xlsxwriter')
    df.to_excel(writer, sheet_name='Sheet1', index=False)

    workbook = writer.book
    worksheet = writer.sheets['Sheet1']
    no_border_format = workbook.add_format({'border': 0})

    for col_num, value in enumerate(df.columns.values):
        worksheet.write(0, col_num, value, no_border_format)

    writer.close()
    print(f"‚úÖ Saved: {filepath}")
    return filepath

# -------------------------------
# RUN PIPELINE
# -------------------------------
def run_pipeline(input_path, list_name, output_folder):
    # Create individual output folder
    individual_output_folder = os.path.join(output_folder, list_name)
    ensure_folder(individual_output_folder)

    # Subfolders
    subfolders = ["SkipTraced", "2BSkip", "CC Ready", "SC Ready", "GHL Ready", "No Hit"]
    for folder in subfolders:
        ensure_folder(os.path.join(individual_output_folder, folder))

    step01_folder = os.path.join(individual_output_folder, "SkipTraced")
    filepath_01 = os.path.join(step01_folder, f"{list_name}.xlsx")

    if os.path.exists(filepath_01):
        print(f"Found existing step01 file: {filepath_01}. Loading it instead of reprocessing.")
        df_01 = pd.read_excel(filepath_01)
    else:
        if input_path.endswith('.csv'):
            df_raw = pd.read_csv(input_path)
        elif input_path.endswith('.xlsx'):
            df_raw = pd.read_excel(input_path)
        else:
            raise ValueError("Unsupported input file type.")
        df_01 = step_01_clean_and_standardize(df_raw, list_name)
        save_to_folder(df_01, step01_folder, list_name)

    df_02 = step_02_remove_phones(df_01)
    filepath_02 = save_to_folder(df_02, os.path.join(individual_output_folder, "2BSkip"), list_name)

    df_03 = step_03_dedupe_and_cleanup(df_01, list_name, individual_output_folder)
    filepath_03 = save_to_folder(df_03, os.path.join(individual_output_folder, "CC Ready"), list_name)

    

    df_04 = step_04_process_phones(pd.read_excel(filepath_03))
    filepath_04 = save_to_folder(df_04, os.path.join(individual_output_folder, "SC Ready"), list_name)

    df_05 = step_05_reshape(pd.read_excel(filepath_04))
    filepath_05 = save_to_folder(df_05, os.path.join(individual_output_folder, "GHL Ready"), list_name)

    

    remove_phone6_from_cc_ready(filepath_03)
    remove_type_columns_from_cc_ready(filepath_03)
        # Reorder No Hit file if it exists
    reorder_nohit_file(os.path.join(individual_output_folder, "No Hit", f"{list_name}.xlsx"))
    





    

    # Tracker
    no_hit_path = os.path.join(individual_output_folder, "No Hit", f"{list_name}.xlsx")

    tracker_data = {
        "SkipTraced": filepath_01,
        "2BSkip": filepath_02,
        "CC Ready": filepath_03,
        "SC Ready": filepath_04,
        "GHL Ready": filepath_05,
        "No Hit File": no_hit_path
    }

    tracker_lines = []
    for label, path in tracker_data.items():
        try:
            if os.path.exists(path):
                df_tmp = pd.read_excel(path)
                count = df_tmp["List"].notna().sum() if "List" in df_tmp.columns else len(df_tmp)
            else:
                count = 0  # If file missing ‚Üí 0
            tracker_lines.append(f"{label}: {count}")
        except Exception as e:
            tracker_lines.append(f"{label}: Error reading file - {str(e)}")

    tracker_path = os.path.join(individual_output_folder, "List Building Records.txt")
    with open(tracker_path, "w") as f:
        f.write("\n".join(tracker_lines))

    print("üìã Tracker saved at:", tracker_path)

    return [filepath_01, filepath_02, filepath_03, filepath_04, filepath_05, no_hit_path]

# -------------------------------
# PROCESS DIRECTORY
# -------------------------------
def process_directory(input_folder):
    output_folder = os.path.join(input_folder, "Processed")
    ensure_folder(output_folder)

    for filename in os.listdir(input_folder):
        if filename.lower().endswith(('.csv', '.xlsx')):
            input_path = os.path.join(input_folder, filename)
            list_name = os.path.splitext(filename)[0]
            print(f"‚ö° Processing {filename} ...")
            try:
                run_pipeline(input_path, list_name, output_folder)
            except Exception as e:
                print(f"‚ùå Failed on {filename}: {e}")

# -------------------------------
# CC Ready File Processor
# -------------------------------
def process_individual_cc_ready_file(file_path):
    return remove_type_columns_from_cc_ready(file_path)

# -------------------------------
# Remove Phone6 from CC Ready
# -------------------------------
def remove_phone6_from_cc_ready(file_path):
    try:
        df = pd.read_excel(file_path)
        if "Phone6" in df.columns:
            df = df.drop(columns=["Phone6"], errors="ignore")

            writer = pd.ExcelWriter(file_path, engine="xlsxwriter")
            df.to_excel(writer, sheet_name="Sheet1", index=False)

            workbook = writer.book
            worksheet = writer.sheets["Sheet1"]
            no_border_format = workbook.add_format({"border": 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()
            print(f"‚úÖ Removed Phone6 column from: {file_path}")
        return df
    except Exception as e:
        print(f"‚ùå Error removing Phone6 from CC Ready file: {str(e)}")
        return None



def reorder_nohit_file(no_hit_path):
    """
    If No Hit file exists, reorder its columns so that:
    Phone1, Type1, ..., Phone6, Type6, Email, List
    """
    if os.path.exists(no_hit_path):
        try:
            df = pd.read_excel(no_hit_path)

            # Define the desired column order
            phone_type_cols = []
            for i in range(1, 7):
                phone_type_cols.append(f"Phone{i}")
                phone_type_cols.append(f"Type{i}")

            final_order = phone_type_cols + ["Email", "List"]

            # Keep only columns that exist in df
            ordered_cols = [col for col in final_order if col in df.columns]
            remaining_cols = [col for col in df.columns if col not in ordered_cols]

            df = df[ remaining_cols + ordered_cols]

            # Overwrite the file with reordered columns
            writer = pd.ExcelWriter(no_hit_path, engine="xlsxwriter")
            df.to_excel(writer, sheet_name="Sheet1", index=False)

            workbook = writer.book
            worksheet = writer.sheets["Sheet1"]
            no_border_format = workbook.add_format({"border": 0})

            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, no_border_format)

            writer.close()

            print(f"‚úÖ Reordered columns in No Hit file: {no_hit_path}")
            return df

        except Exception as e:
            print(f"‚ùå Error reordering No Hit file: {e}")
            return None
    else:
        print(f"‚ÑπÔ∏è No Hit file not found at {no_hit_path}")
        return None

# -------------------------------
# Main
# -------------------------------
if __name__ == "__main__":
    print("Pipeline Script Loaded")
    print("Available functions:")
    print("- process_directory(input_folder)")
    print("- run_pipeline(input_path, list_name, output_folder)")
    print("- process_individual_cc_ready_file(file_path)")


run.py file which is not nessary at all

so make full script of above files again and give it me 